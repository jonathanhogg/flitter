
# Windows

The primary visual output from a **Flitter** program is normally through
windows. Windows are explicitly created rather than there being some default
output space. This allows for multiple windows to be created and controlled
simultaneously with a single program. It also allows properties of the windows
to be controlled.

In order to render anything, a *window rendering tree* is defined by placing
one or more output nodes inside the window. Each of these rendering nodes
creates (at least) one OpenGL texture as an output. Some of these nodes may
have children and the textures generated by these become input textures to those
nodes.

The window rendering nodes are:

`!window`
: An on-screen window. This is always a top-level node in a **Flitter** program.
It may have multiple child nodes.

`!offscreen`
: An off-screen window. This is always a top-level node in a **Flitter**
program.

`!shader`
: An OpenGL shader program. This may appear as a child node anywhere in the
window rendering tree. It may have multiple child nodes.

`!image`
: Loads an image from an external file. This may appear as a child node anywhere
in the window rendering tree.

`!video`
: Loads and plays a video from an external file. This may appear as a child node
anywhere in the window rendering tree.

`!canvas`
: A 2D drawing canvas. This may appear as a child node anywhere in the window
rendering tree.

`!canvas3d`
: A [3D drawing canvas](canvas3d.md). This may appear as a child node anywhere
in the window rendering tree.

`!record`
: This node can record its output directly to an image or video file. This may
appear as a child node anywhere in the window rendering tree. It may have
multiple child nodes.

`!reference`
: Allows the output of a named window rendering node to be used elsewhere in the
tree.

## Common attributes

All window rendering nodes share a common structure and so they share some
common attributes:

`size=` *WIDTH*`;`*HEIGHT*
: Specifies the size of the texture that this node will render into. This value
is inherited from the parent node if not specified or, in the case of `!image`
and `!video` nodes, matched to the content.

`id=` *ID*
: Specifies a string or symbol identifier for this node that allows the output
texture from it to be referenced from elsewhere – either a `!reference` node,
a [texture map](canvas3d,md#texture-mapping) on a 3D model, or as an [image or
pattern](canvas.md#using-external-textures) in a 2D drawing.

`hidden=` [ `true` | `false` ]
: This is valid on any child node (i.e., not on `!window` or `!offscreen`).
Setting this attribute to `true` will cause the parent node to ignore this node
as a child. The output will still be rendered, which means it can still be
referenced.

In addition, `!window`, `!offscreen`, `!shader`, `!video` and `!record` are all
*program nodes* that run an OpenGL shader program. These programs can be changed
with the following attributes:

`vertex=` *STRING*
: Specifies an override vertex shader as a text string containing the GLSL code.
Usually this would be read from a file with the [`read()` built-in
function](builtins.md#file-functions). If unspecified, a standard internal
shader will be used.

`fragment=` *STRING*
: Specifies an override fragment shader as a text string containing the GLSL
code. Usually this would be read from a file with the [`read()` built-in
function](builtins.md#file-functions). If unspecified, a standard internal
shader will be used.

The shader program for `!video` has a specific function related to the rendering
of video frames and so changing this shader is not advised unless you know what
you are doing. However, the other nodes follow a standard scheme that is
described below for [`!shader`](#shader).

:::{warning}
Although the `!canvas3d` node supports `vertex` and `fragment` shader
attributes, these actually override the model instance shader program for the
default [render group](canvas3d.md#render-groups). This is a much more
specialised program and writing a new one is a more complicated endeavour.
:::

## `!window` and `!offscreen`

The `!window` and `!offscreen` nodes are largely identical except for the
latter not opening on-screen. `!offscreen` nodes are primarily intended to
collect window rendering nodes that are to be used as references rather than
through direct rendering into a window. However, all `!window` nodes can be made
to behave as `!offscreen` nodes with the `--offscreen` [command-line
option](install,md#command-line-options). This can be useful for running tests
or for saving output to files without opening a window.

`!window` and `!offscreen` nodes support the following specific attributes:

`linear=` [ `true` | `false` ]
: This specifies the whether linear or logarithmic color-handling is desired.
This only affects the behaviour of [`!canvas` 2D drawing](canvas.md) nodes.
All other color processing in the pipeline assumes linear color-handling.

`colorbits=` [ `8` | `16` | `32` ]
: This specifies the default bit depth of output texture color channels for the
window rendering tree. If not specified, it defaults to `16` bits. The color
depth of `!window` and `!offscreen` frame-buffers cannot be controlled and is
OS-defined.

The default shader program behaviour for `!window` and `!offscreen` is the same
as that for [`!shader` below](#shader).

## `!shader`

The `!shader` node allows insertion of an arbitrary OpenGL shader program into
the window render tree. `!shader` nodes support the following attribute:

`colorbits=` [ `8` | `16` | `32` ]
: This overrides the default color channel bit depth for this node's output
texture.

The default shader program (and that also used for `!window`, `!offscreen` and
`!record` nodes) composites together the output textures of all child nodes with
a blend function that can be controlled with the following attribute:

`composite=` [ `:over` | `:dest_over` | `:lighten` | `:darken` | `:add` | `:difference` | `:multiply` ]
: Specifies the blend function to use in the standard compositing shader
program. Defaults to `:over`.

If more specialised behaviour is required then a custom shader program can be
specified. The rendering approach is as follows:

- A single quad covering the whole output frame-buffer is rendered
- The default vertex shader passes standardized $[0,1]$ UV coordinates to the
fragment `out vec2 coord`
- The fragment shader is expected to declare an `out vec4` fragment color that
will be written to the node's texture

The vertex and fragment shaders have a number of available uniforms that
will be populated if declared:

`uniform vec2 size`
: Will be set to the the pixel-size of the node's output frame-buffer, the
`coord` UV coordinates can be multiplied by this to get actual pixel
coordinates in the fragment shader.

`uniform float beat`
: The current beat counter.

`uniform float quantum`
: The current quantum.

`uniform float tempo`
: The current tempo.

`uniform float delta`
: The difference between the current beat counter and the its value on the last
frame.

`uniform float clock`
: The current frame time in seconds.

`uniform int fps`
: The target frame-rate.

`uniform float performance`
: A value in the range $[0.5,2]$ that indicates how well the engine is managing
to hit the target frame-rate.

`uniform sampler2D` [ `texture0` | `texture1` | … ]
: These will be bound to the texture of each child node in turn.

`uniform sampler2D last`
: If specified, this will cause an additional texture to be created that will
retain the node texture output at the last frame. This can be used to implement
feedback-style effects.

In addition to these, the shader program may declare arbitrary numeric uniforms
that can be set using attributes with matching names on the shader node.
`float`, `vec2`, `vec3` and `vec4` uniforms expect 1-, 2- , 3- and 4-item
numeric vectors, respectively; arrays of these types expect vectors with an
appropriate multiple of these sizes.

## `!image`

## `!video`

## `!reference`

The output texture of one node in a window rendering tree can be used in
multiple places in the tree with a `!reference` node. The node takes a single
attribute:

`id=` *ID*
: Specifies the value of the `id` attribute of matching node.

For example, a bloom-filter pipeline might look like this:

```flitter
let SIZE=1920;1080

!window size=SIZE blend=:lighten
    !canvas3d id=:bloom_source
        …
    !shader fragment=read('blur.frag') radius=5
        !shader fragment=read('threshold.frag') level=0.5
            !reference id=:bloom_source
```

This allows the `!canvas3d` output to appear at two places in the window
rendering tree: as a direct child of the window, and as an input to the
`threshold.frag` shader program.
