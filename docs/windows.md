
# Windows

The primary visual output from a **Flitter** program is normally through
windows. Windows are explicitly created rather than there being some default
output space. This allows for multiple windows to be created and controlled
simultaneously with a single program. It also allows properties of the windows
to be controlled.

In order to render anything, a *window rendering tree* is defined by placing
one or more output nodes inside the window. Each of these rendering nodes
creates (at least) one OpenGL texture as an output. Some of these nodes may
have children and the textures generated by these become input textures to those
nodes.

The window rendering nodes are:

`!window`
: An on-screen window. This is always a top-level node in a **Flitter** program.
It may have multiple child nodes.

`!offscreen`
: An off-screen window. This is always a top-level node in a **Flitter**
program.

`!shader`
: An OpenGL shader program. This may appear as a child node anywhere in the
window rendering tree. It may have multiple child nodes.

`!image`
: Loads an image from an external file. This may appear as a child node anywhere
in the window rendering tree.

`!video`
: Loads and plays a video from an external file. This may appear as a child node
anywhere in the window rendering tree.

`!canvas`
: A 2D drawing canvas. This may appear as a child node anywhere in the window
rendering tree.

`!canvas3d`
: A [3D drawing canvas](canvas3d.md). This may appear as a child node anywhere
in the window rendering tree.

`!record`
: This node can record its output directly to an image or video file. This may
appear as a child node anywhere in the window rendering tree. It may have
multiple child nodes.

`!reference`
: Allows the output of a named window rendering node to be used elsewhere in the
tree.

## Common attributes

All window rendering nodes share a common structure and so they share some
common attributes:

`size=` *WIDTH*`;`*HEIGHT*
: Specifies the size of the texture that this node will render into. This value
is inherited from the parent node if not specified or, in the case of `!image`
and `!video` nodes, matched to the content.

`id=` *ID*
: Specifies a string or symbol identifier for this node that allows the output
texture from it to be referenced from elsewhere – either a `!reference` node,
a [texture map](canvas3d,md#texture-mapping) on a 3D model, or as an [image or
pattern](canvas.md#using-external-textures) in a 2D drawing.

`hidden=` [ `true` | `false` ]
: This is valid on any child node (i.e., not on `!window` or `!offscreen`).
Setting this attribute to `true` will cause the parent node to ignore this node
as a child. The output will still be rendered, which means it can still be
referenced.

In addition, `!window`, `!offscreen`, `!shader`, `!video` and `!record` are all
*program nodes* that run an OpenGL shader program. These programs can be changed
with the following attributes:

`vertex=` *STRING*
: Specifies an override vertex shader as a text string containing the GLSL code.
Usually this would be read from a file with the [`read()` built-in
function](builtins.md#file-functions). If unspecified, a standard internal
shader will be used.

`fragment=` *STRING*
: Specifies an override fragment shader as a text string containing the GLSL
code. Usually this would be read from a file with the [`read()` built-in
function](builtins.md#file-functions). If unspecified, a standard internal
shader will be used.

The shader program for `!video` has a specific function related to the rendering
of video frames and so changing this shader is not advised unless you know what
you are doing. However, the other nodes follow a standard scheme that is
described below for [`!shader`](#shader).

:::{warning}
Although the `!canvas3d` node supports `vertex` and `fragment` shader
attributes, these actually override the model instance shader program for the
default [render group](canvas3d.md#render-groups). This is a much more
specialised program and writing a new one is a more complicated endeavour.
:::

## `!window` and `!offscreen`

The `!window` and `!offscreen` nodes are largely identical except for the
latter not opening on-screen. `!offscreen` nodes are primarily intended to
collect window rendering nodes that are to be used as references rather than
through direct rendering into a window. However, all `!window` nodes can be made
to behave as `!offscreen` nodes with the `--offscreen` [command-line
option](install,md#command-line-options). This can be useful for running tests
or for saving output to files without opening a window.

`!window` and `!offscreen` nodes support the following specific attributes:

`linear=` [ `true` | `false` ]
: This specifies the whether linear or logarithmic color-handling is desired.
This only affects the behaviour of [`!canvas` 2D drawing](canvas.md) nodes.
All other color processing in the pipeline assumes linear color-handling.

`colorbits=` [ `8` | `16` | `32` ]
: This specifies the default bit depth of output texture color channels for the
window rendering tree. If not specified, it defaults to `16` bits. The color
depth of `!window` and `!offscreen` frame-buffers cannot be controlled and is
OS-defined.

The default shader program behaviour for `!window` and `!offscreen` is the same
as that for [`!shader` below](#shader).

## `!shader`

The `!shader` node allows insertion of an arbitrary OpenGL shader program into
the window render tree. `!shader` nodes support the following attribute:

`colorbits=` [ `8` | `16` | `32` ]
: This overrides the default color channel bit depth for this node's output
texture.

The default shader program (and that also used for `!window`, `!offscreen` and
`!record` nodes) composites together the output textures of all child nodes with
a blend function that can be controlled with the following attribute:

`composite=` [ `:over` | `:dest_over` | `:lighten` | `:darken` | `:add` | `:difference` | `:multiply` ]
: Specifies the blend function to use in the standard compositing shader
program. Defaults to `:over`.

If more specialised behaviour is required then a custom shader program can be
specified. The rendering approach is as follows:

- A single quad covering the whole output frame-buffer is rendered
- The default vertex shader passes standardized $[0,1]$ UV coordinates to the
fragment `out vec2 coord`
- The fragment shader is expected to declare an `out vec4` fragment color that
will be written to the node's texture

The vertex and fragment shaders have a number of available uniforms that
will be populated if declared:

`uniform vec2 size`
: Will be set to the the pixel-size of the node's output frame-buffer, the
`coord` UV coordinates can be multiplied by this to get actual pixel
coordinates in the fragment shader.

`uniform float beat`
: The current beat counter.

`uniform float quantum`
: The current quantum.

`uniform float tempo`
: The current tempo.

`uniform float delta`
: The difference between the current beat counter and the its value on the last
frame.

`uniform float clock`
: The current frame time in seconds.

`uniform int fps`
: The target frame-rate.

`uniform float performance`
: A value in the range $[0.5,2]$ that indicates how well the engine is managing
to hit the target frame-rate.

`uniform sampler2D` [ `texture0` | `texture1` | … ]
: These will be bound to the texture of each child node in turn.

`uniform sampler2D last`
: If specified, this will cause an additional texture to be created that will
retain the node texture output at the last frame. This can be used to implement
feedback-style effects.

In addition to these, the shader program may declare arbitrary numeric uniforms
that can be set using attributes with matching names on the shader node.
`float`, `vec2`, `vec3` and `vec4` uniforms expect 1-, 2- , 3- and 4-item
numeric vectors, respectively; arrays of these types expect vectors with an
appropriate multiple of these sizes.

## `!image`

An `!image` node loads the contents of an external image file into a texture
for use in the window rendering tree. This might be as an input to a `!shader`,
for displaying static slideshow images in a `!window`, or in an `!offscreen` to
use as a referenced texture for [3D model texture
mapping](canvas3d.md#texture-mapping).

There are two supported attributes:

`filename=` *PATH*
: Specifies the path of the file to load with respect to the location of the
running **Flitter** program.

`size=` *WIDTH*`;`*HEIGHT*
: If specified, then the image will be resized to this size with bilinear
interpolation.

Unlike the rest of the window rendering nodes, `!image` does not inherit its
size from its parent. If `size` is not specified, then the output texture size
will match the pixel dimensions of the loaded image.

The `!image` output texture is only changed if the underlying file changes, or
the `filename` or `size` attributes are changed. This makes it a very cheap
node to render compared to, say, creating a `!canvas` node and drawing an image
into it. `!image` can load all image file types [supported by the **Pillow**
image library](https://pillow.readthedocs.io/en/stable/handbook/image-file-formats.html).

## `!video`

A `!video` node loads and renders frames from an external video file into a
texture. The following attributes are supported:

`filename=` *PATH*
: Specifies the path of the video to open with respect to the location of the
running **Flitter** program.

`position=` *TIMESTAMP*
: Specifies the time-stamp, in seconds from the start of the video, of the
frame to be output.

`loop=` [ `true` | `false` ]
: Specifies whether the time-stamps beyond the end of the video will loop around
to the beginning. This also enables negative time-stamps, which will loop around
to the end. If set to `false` (the default), time-stamps outside of the video
range will be clamped to the first or last frames of the video.

`interpolate=` [ `true` | `false` ]
: Specifies whether to mix two successive frames if `position` references a
value between the frame time-stamps. This can be useful for generating
slow-motion output if the video does not contain too much fast movement. The
default is `false`.

`thread=` [ `true` | `false` ]
: Specifies whether to use multi-threaded video decoding. This has higher
overall performance, but introduces a small delay on the first frame. This delay
may be unacceptable if the video needs to start immediately on load.

Like `!image`, `!video` does not inherit its size from its parent. However,
unlike `!image`, the `!video` output texture will *always* match the pixel
dimensions of the video and any `size` attribute is ignored.

A video is played by setting the `position` attribute to a time-varying value
in code. There is no requirement for this value to vary at real-time, it can
slow to a stop or run faster. `position` may skip forward or backwards by a
large step, which will cause a frame seek to the new location.

:::{warning}
`position` may run *backwards*. However there is an important caveat: if the
video makes use of P-frames or B-frames then this will cause a slight judder at
each I-frame boundary. The video player will seek back to the next I-frame
and then decode forwards to the desired frame. The in-between frames are cached,
but the same seek and decode forwards will have to be done when each successive
I-frame is hit.
:::

`!video` uses the [**PyAV** library](https://pyav.org), which is a wrapper
around **ffmpeg**. It thus supports a very wide range of video file types.

## `!record`

Record composites its child nodes – like a standard `!shader` node – but does
this to a texture which is then written to an image or video file.

If the  `!record` node has only one child, then the output texture from
`!record` into the rest of the window rendering tree will be the output texture
of that child. This allows a `!record` node to be inserted into a tree without
disturbing the normal rendering pipeline. This is particularly important if the
output image is being written at a smaller size to the child node.

:::{warning}
If the `!record` node has multiple children, then its output texture will be the
same texture that is written to the file, which may include not just resizing,
but also a shallower color channel bit depth and transformation into sRGB
logarithmic color space.

If this is to be avoided, then the simplest approach is to move the `!record`
node out of the rendering path and provide its input using a
[`!reference`](#reference) node.
:::

## `!reference`

The output texture of one node in a window rendering tree can be used in
multiple places in the tree with a `!reference` node. The node takes a single
attribute:

`id=` *ID*
: Specifies the value of the `id` attribute of matching node.

For example, a bloom-filter pipeline might look like this:

```flitter
let SIZE=1920;1080

!window size=SIZE blend=:lighten
    !canvas3d id=:bloom_source
        …
    !shader fragment=read('blur.frag') radius=5
        !shader fragment=read('threshold.frag') level=0.5
            !reference id=:bloom_source
```

This allows the `!canvas3d` output to appear at two places in the window
rendering tree: as a direct child of the window, and as an input to the
`threshold.frag` shader program.
