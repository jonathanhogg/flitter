
# Windows

The primary visual output from a **Flitter** program is normally through
windows. Windows are explicitly created rather than there being some default
output space. This allows for multiple windows to be created and controlled
simultaneously with a single program. It also allows properties of the windows
to be controlled.

In order to render anything, a *window rendering tree* is defined by placing
one or more output nodes inside the window. Each of these rendering nodes
creates (at least) one OpenGL texture as an output. Some of these nodes may
have children and the textures generated by these become input textures to those
nodes.

The window rendering nodes are:

`!window`
: An on-screen window. This is always a top-level node in a **Flitter** program.
It may have multiple child nodes.

`!offscreen`
: An off-screen window. This is always a top-level node in a **Flitter**
program.

`!shader`
: An OpenGL shader program. This may appear as a child node anywhere in the
window rendering tree. It may have multiple child nodes.

`!image`
: Loads an image from an external file. This may appear as a child node anywhere
in the window rendering tree.

`!video`
: Loads and plays a video from an external file. This may appear as a child node
anywhere in the window rendering tree.

`!canvas`
: A 2D drawing canvas. This may appear as a child node anywhere in the window
rendering tree.

`!canvas3d`
: A [3D drawing canvas](canvas3d.md). This may appear as a child node anywhere
in the window rendering tree.

`!record`
: This node can record its output directly to an image or video file. This may
appear as a child node anywhere in the window rendering tree. It may have
multiple child nodes.

`!reference`
: Allows the output of a named window rendering node to be used elsewhere in the
tree.

## Common attributes

All window rendering nodes share a common structure and so they share some
common attributes:

`size=` *WIDTH*`;`*HEIGHT*
: Specifies the size of the texture that this node will render into. This value
is inherited from the parent node if not specified or, in the case of `!image`
and `!video` nodes, matched to the content.

`id=` *ID*
: Specifies a string or symbol identifier for this node that allows the output
texture from it to be referenced from elsewhere – either a `!reference` node,
a [texture map](canvas3d,md#texture-mapping) on a 3D model, or as an [image or
pattern](canvas.md#using-external-textures) in a 2D drawing.

`hidden=` [ `true` | `false` ]
: This is valid on any child node (i.e., not on `!window` or `!offscreen`).
Setting this attribute to `true` will cause the parent node to ignore this node
as a child. The output will still be rendered, which means it can still be
referenced.

In addition, `!window`, `!offscreen`, `!shader`, `!video` and `!record` are all
*program nodes* that run an OpenGL shader program. These programs can be changed
with the following attributes:

`vertex=` *STRING*
: Specifies an override vertex shader as a text string containing the GLSL code.
Usually this would be read from a file with the [`read()` built-in
function](builtins.md#file-functions). If unspecified, a standard internal
shader will be used.

`fragment=` *STRING*
: Specifies an override fragment shader as a text string containing the GLSL
code. Usually this would be read from a file with the [`read()` built-in
function](builtins.md#file-functions). If unspecified, a standard internal
shader will be used.

The shader program for `!video` has a specific function related to the rendering
of video frames and so changing this shader is not advised unless you know what
you are doing. However, the other nodes follow a standard scheme that is
described below for [`!shader`](#shader).

:::{warning}
Although the `!canvas3d` node supports `vertex` and `fragment` shader
attributes, these actually override the model instance shader program for the
default [render group](canvas3d.md#render-groups). This is a much more
specialised program and writing a new one is a more complicated endeavour.
:::

## `!window` and `!offscreen`

The `!window` and `!offscreen` nodes are largely identical except for the
latter not opening on-screen. `!offscreen` nodes are primarily intended to
collect window rendering nodes that are to be used as references rather than
through direct rendering into a window. However, all `!window` nodes can be made
to behave as `!offscreen` nodes with the `--offscreen` [command-line
option](install,md#command-line-options). This can be useful for running tests
or for saving output to files without opening a window.

`!window` and `!offscreen` nodes support the following specific attributes:

`linear=` [ `true` | `false` ]
: This specifies the whether linear or logarithmic color-handling is desired.
This only affects the behaviour of [`!canvas` 2D drawing](canvas.md) nodes.
All other color processing in the pipeline assumes linear color-handling.

`colorbits=` [ `8` | `16` | `32` ]
: This specifies the default bit depth of output texture color channels for the
window rendering tree. If not specified, it defaults to `16` bits. The color
depth of `!window` and `!offscreen` frame-buffers cannot be controlled and is
OS-defined.

The default shader program behaviour for `!window` and `!offscreen` is the same
as that for [`!shader` below](#shader).

### `!key` and `!pointer`

`!window` nodes support a basic input system similar to
[controllers](controllers.md) that allows keyboard and pointer input to be
connected to the [state system](language.md#state). This is controlled by
adding one or more `!key` nodes as children of the `!window` node and/or a
`!pointer` node.

`!key` nodes support the following attributes:

`state=` *PREFIX*
: The prefix for state keys related to this key.

`name=` *NAME*
: The *name* of the key as a string or symbol. The key names are those defined
by [GLFW](https://www.glfw.org/docs/latest/group__keys.html) (without the
leading `GLFW_KEY_` prefix).

A `!key` node must be given for each key that the program is interested in. The
following entries will be created in the state mapping for each key:

*PREFIX*
: A value of `true` if the key is currently pressed, `false` if it is released
or `null` if this is unknown.

*PREFIX* `;pushed`
: This is the same value as the *PREFIX* key.

*PREFIX* `;pushed;:beat`
: The beat counter value at the moment that the key was *last* pressed, or
`null` if this event has not yet occurred.

*PREFIX* `;released`
: This is the logical negation of the the *PREFIX* key value, i.e., `true` if
the key is currently *released*, `false` if it is *pressed* or `null` if this is
unknown.

*PREFIX* `;released;:beat`
: The beat counter value at the moment that the key was *last* released, or
`null` if this event has not yet occurred.

A `!pointer` node supports just the `state` attribute and creates the following
entries in the state mapping:

*PREFIX*
: The current pointer position as a 2-item vector normalized to the $[0,1]$
range, where $0$ is the left/top of the window and $1$ is the right/bottom. If
the pointer is not within the bounds of the window then this state key will be
`null`.

*PREFIX* `;` (`0` | `1` | … )
: The status of the pointer button(s), numbered from `0` upwards – which of
these is "left" or "right" is OS dependent. The state value will be `true` if
the pointer button is currently pressed, `false` if it is released or `null` if
the state is not currently known (for instance the window has just opened and
no pointer events have been processed).

## `!shader`

The `!shader` node allows insertion of an arbitrary OpenGL shader program into
the window render tree. `!shader` nodes support the following attribute:

`colorbits=` [ `8` | `16` | `32` ]
: This overrides the default color channel bit depth for this node's output
texture.

The default shader program (and that also used for `!window`, `!offscreen`
nodes) composites together the output textures of all child nodes with a blend
function that can be controlled with the following attribute:

`composite=` [ `:over` | `:dest_over` | `:lighten` | `:darken` | `:add` | `:difference` | `:multiply` ]
: Specifies the blend function to use in the standard compositing shader
program. Defaults to `:over`.

If more specialised behaviour is required then a custom shader program can be
specified. The rendering approach is as follows:

- A single quad covering the whole output frame-buffer is rendered
- The default vertex shader passes standardized $[0,1]$ UV coordinates to the
fragment `out vec2 coord`
- The fragment shader is expected to declare an `out vec4` fragment color that
will be written to the node's texture

The vertex and fragment shaders have a number of available uniforms that
will be populated if declared:

`uniform vec2 size`
: Will be set to the the pixel-size of the node's output frame-buffer, the
`coord` UV coordinates can be multiplied by this to get actual pixel
coordinates in the fragment shader.

`uniform float beat`
: The current beat counter.

`uniform float quantum`
: The current quantum.

`uniform float tempo`
: The current tempo.

`uniform float delta`
: The difference between the current beat counter and the its value on the last
frame.

`uniform float clock`
: The current frame time in seconds.

`uniform int fps`
: The target frame-rate.

`uniform float performance`
: A value in the range $[0.5,2]$ that indicates how well the engine is managing
to hit the target frame-rate.

`uniform sampler2D` [ `texture0` | `texture1` | … ]
: These will be bound to the texture of each child node in turn.

`uniform sampler2D last`
: If specified, this will cause an additional texture to be created that will
retain the node texture output at the last frame. This can be used to implement
feedback-style effects.

In addition to these, the shader program may declare arbitrary numeric uniforms
that can be set using attributes with matching names on the shader node.
`float`, `vec2`, `vec3` and `vec4` uniforms expect 1-, 2- , 3- and 4-item
numeric vectors, respectively; arrays of these types expect vectors with an
appropriate multiple of these sizes.

## `!image`

An `!image` node loads the contents of an external image file into a texture
for use in the window rendering tree. This might be as an input to a `!shader`,
for displaying static slideshow images in a `!window`, or in an `!offscreen` to
use as a referenced texture for [3D model texture
mapping](canvas3d.md#texture-mapping).

There are two supported attributes:

`filename=` *PATH*
: Specifies the path of the file to load with respect to the location of the
running **Flitter** program.

`size=` *WIDTH*`;`*HEIGHT*
: If specified, then the image will be resized to this size with bilinear
interpolation.

Unlike the rest of the window rendering nodes, `!image` does not inherit its
size from its parent. If `size` is not specified, then the output texture size
will match the pixel dimensions of the loaded image.

The `!image` output texture is only changed if the underlying file changes, or
the `filename` or `size` attributes are changed. This makes it a very cheap
node to render compared to, say, creating a `!canvas` node and drawing an image
into it. `!image` can load all image file types [supported by the **Pillow**
image library](https://pillow.readthedocs.io/en/stable/handbook/image-file-formats.html).

## `!video`

A `!video` node loads and renders frames from an external video file into a
texture. The following attributes are supported:

`filename=` *PATH*
: Specifies the path of the video to open with respect to the location of the
running **Flitter** program.

`position=` *TIMESTAMP*
: Specifies the time-stamp, in seconds from the start of the video, of the
frame to be output.

`loop=` [ `true` | `false` ]
: Specifies whether the time-stamps beyond the end of the video will loop around
to the beginning. This also enables negative time-stamps, which will loop around
to the end. If set to `false` (the default), time-stamps outside of the video
range will be clamped to the first or last frames of the video.

`interpolate=` [ `true` | `false` ]
: Specifies whether to mix two successive frames if `position` references a
value between the frame time-stamps. This can be useful for generating
slow-motion output if the video does not contain too much fast movement. The
default is `false`.

`thread=` [ `true` | `false` ]
: Specifies whether to use multi-threaded video decoding. This has higher
overall performance, but introduces a small delay on the first frame. This delay
may be unacceptable if the video needs to start immediately on load.

Like `!image`, `!video` does not inherit its size from its parent. However,
unlike `!image`, the `!video` output texture will *always* match the pixel
dimensions of the video and any `size` attribute is ignored.

A video is played by setting the `position` attribute to a time-varying value
in code. There is no requirement for this value to vary at real-time, it can
slow to a stop or run faster. `position` may skip forward or backwards by a
large step, which will cause a frame seek to the new location.

:::{warning}
`position` may run *backwards*. However there is an important caveat: if the
video makes extensive use of
[P-frames](https://en.wikipedia.org/wiki/Video_compression_picture_types) then
this will cause a slight judder at each I-frame boundary. The video player will
need to seek back to the previous I-frame and then decode forwards to the
desired frame. The in-between frames are cached, but the same seek and decode
forwards will have to be done each time an I-frame is hit.
:::

`!video` uses the [**PyAV** library](https://pyav.org), which is a wrapper
around [**ffmpeg**](https://ffmpeg.org). It thus supports a very wide range of
video file types.

## `!record`

The `!record` node expects a single child node which will be written to an
image or video file and then passed through untouched as the output texture
of the `!record` node. If a number of children need to be composited together
for output, then place a [`!shader`](#shader) node between them and `!record`.

`!record` supports the following attributes:

`filename=` *PATH*
: Specifies the path of the image or video file to write to, with respect to the
location of the running **Flitter** program. Whether the output is an image or
a video depends on the extension of the filename. If `filename` is `null`, then
the `!record` node will do nothing – this is a simple way to delay output until
when a particular condition holds.

`quality=` *Q*
: Specifies a quality setting for image formats that support it (such as JPEG).

`codec=` *CODEC*
: For generic video container outputs, this specifies the video codec to use.
Defaults to `:h264`.

`crf=` *CRF*
: For video codecs that support it, this provides a "constant rate factor" that
defines how much the codec should prioritise size over quality. Smaller values
mean better quality and larger values mean a smaller size. A value around `25`
is generally an acceptable compromise for the `:h264` codec. For `:h265`, this
can often be pushed up to a higher value for smaller files while still keeping
a decent quality encoding.

`preset=` *PRESET*
: Specifies a video codec preset if supported. This bunches up different codec
settings. Common presets have names like `:fast` or `:slow` and the
[**ffmpeg**](https://ffmpeg.org) documentation should be referred to for
details.

`limit=` *SECONDS*
: Specifies a maximum number of seconds of video output to write before closing
the file. Otherwise, the video output will continue for as long as `filename` is
valid and the program is running.

Filenames with an `.mp4`, `.mov`, `.m4v`, `.mkv`, `.webm` or `.ogg` extension
are assumed to be video outputs with the appropriate container type. In
addition, if the extension is `.gif` and `codec=:gif` is *also* supplied, then
an animated GIF file will be written with the video output path. Otherwise a
static GIF image will be written.

A particular image file will be written once per run of a **Flitter** program,
i.e., once an image has been written to a particular file, the `!record` node
will do nothing. However, the `filename` attribute can be changed to record a
new image. In this way, a constantly changing filename can be used to write
individual animation frames as images. For example, this program will write a
new JPEG snapshot into the `output` folder every beat:

```flitter
!window …
    !record filename='output/frame';beat//1;'.jpg' quality=90
        …
```

## `!reference`

The output texture of one node in a window rendering tree can be used in
multiple places in the tree with a `!reference` node. The node takes a single
attribute:

`id=` *ID*
: Specifies the value of the `id` attribute of matching node.

For example, a bloom-filter pipeline might look like this:

```flitter
let SIZE=1920;1080

!window size=SIZE blend=:lighten
    !canvas3d id=:bloom_source
        …
    !shader fragment=read('blur.frag') radius=5
        !shader fragment=read('threshold.frag') level=0.5
            !reference id=:bloom_source
```

This allows the `!canvas3d` output to appear at two places in the window
rendering tree: as a direct child of the window, and as an input to the
`threshold.frag` shader program.
