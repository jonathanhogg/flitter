
%import common.ESCAPED_STRING
%import common.WS_INLINE
%ignore WS_INLINE
%declare _INDENT _DEDENT


_NL: /(\r?\n[\t ]*)+/

NAME : /[_a-z][_a-z0-9]*/i
TRUE : "true"
FALSE : "false"
NULL : "null"
SIGNED_NUMBER : /[-+]?([0-9]+(\.[0-9]+)?|\.[0-9]+)(e[-+]?[0-9]+)?/i
QUERY : /{[^}]+}/


sequence : _NL? expression+

?expression : node _NL
            | node _NL _INDENT sequence _DEDENT -> append
            | "for" NAME "in" range _NL _INDENT sequence _DEDENT -> loop
            | "let" binding+ _NL -> let
            | "if" tests ["else" _NL _INDENT sequence _DEDENT] -> if_else

tests : test ("elif" test)*

test : composition _NL _INDENT sequence _DEDENT

binding : NAME "=" composition

?node : composition
      | "!" NAME tags -> node
      | node NAME "=" composition -> attribute

?composition : comprehension
             | comprehension (";" comprehension)+ -> sequence

?comprehension : comparison
               | "for" NAME "in" comparison "|" comprehension -> loop

?comparison : range
            | comparison "==" range -> eq
            | comparison "!=" range -> ne
            | comparison "<" range -> lt
            | comparison ">" range -> gt
            | comparison "<=" range -> le
            | comparison ">=" range -> ge

?range : sum
       | [sum] ".." sum [":" sum] -> range

?sum : product
     | sum "+" product -> add
     | sum "-" product -> subtract

?product : power
         | product "*" power -> multiply
         | product "/" power -> divide
         | product "//" power -> floordivide
         | product "%" power -> modulo

?power : atom
       | atom "**" power -> power

?atom : literal
      | NAME -> name
      | "-" atom -> neg
      | atom "(" args ")" -> call
      | atom "[" node "]" -> index
      | QUERY -> search
      | "(" node ")"

literal : SIGNED_NUMBER
        | ESCAPED_STRING
        | TRUE | FALSE
        | NULL

args : (node ("," node)*)?

tags: tag*

?tag: "#" NAME
