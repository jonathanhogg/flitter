
%import common.ESCAPED_STRING
%import common.WS_INLINE
%ignore WS_INLINE
%ignore /\\$\n/m
%declare _INDENT _DEDENT

_NL: /((--[^\r\n]*)?\r?\n[\t ]*)+/

NAME : /[_a-z][_a-z0-9]*/i
SIGNED_NUMBER : /([0-9]+(\.[0-9]+)?|\.[0-9]+)(e[-+]?[0-9]+)?/i
QUERY : /{[^}]+}/


sequence : _NL? expressions

expressions : expression+ -> tuple

?expression : node _NL
            | node "^" _NL _INDENT sequence _DEDENT -> prepend
            | node _NL _INDENT sequence _DEDENT -> append
            | "for" NAME "in" range _NL _INDENT sequence _DEDENT -> loop
            | "let" multiline_bindings -> let
            | "if" tests ("else" _NL _INDENT sequence _DEDENT)? -> if_else
            | "%pragma" NAME node _NL -> pragma
            | "func" NAME "(" names ")" _NL _INDENT sequence _DEDENT -> function

names : (NAME ("," NAME)*)? -> tuple

tests : test ("elif" test)* -> tuple

test : composition _NL _INDENT sequence _DEDENT

?node : composition
      | "!" NAME -> node
      | node "#" NAME -> tag
      | node bindings -> attributes

multiline_bindings : binding+ _NL (_INDENT (binding+ _NL)+ _DEDENT)? -> tuple

bindings : binding+ -> tuple

binding : NAME "=" composition

?composition : comprehension
             | compositions -> sequence

compositions : comprehension (";" comprehension)+ -> tuple

?comprehension : or
               | comprehension "for" NAME "in" or -> inline_loop
               | comprehension "where" inline_bindings -> inline_let
               | or "if" or ("else" comprehension)? -> inline_if_else

inline_bindings: binding+ -> tuple

inline_binding: NAME "=" or -> binding

?or : and
    | or "or" and -> logical_or

?and : not
     | and "and" not -> logical_and

?not : comparison
     | "not" not -> logical_not

?comparison : range
            | comparison "==" range -> eq
            | comparison "!=" range -> ne
            | comparison "<" range -> lt
            | comparison ">" range -> gt
            | comparison "<=" range -> le
            | comparison ">=" range -> ge

?range : sum
       | [sum] ".." sum [":" sum] -> range

?sum : product
     | sum "+" product -> add
     | sum "-" product -> subtract

?product : power
         | product "*" power -> multiply
         | product "/" power -> divide
         | product "//" power -> floor_divide
         | product "%" power -> modulo

?power : unary
       | unary "**" power -> power

?unary : atom
       | "-" atom -> neg
       | "+" atom -> pos

?atom : literal
      | NAME -> name
      | atom "(" args ")" -> call
      | atom "[" node "]" -> slice
      | QUERY -> search
      | "$" atom -> lookup
      | "(" node ")"

args : (node ("," node)*)? -> tuple

literal : SIGNED_NUMBER
        | ESCAPED_STRING
